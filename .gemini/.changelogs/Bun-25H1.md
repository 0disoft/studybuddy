# Bun 25H1 핵심 변경사항

---

## 서론

Bun은 Jarred Sumner가 Node.js의 드롭인 대체품으로 설계한 혁신적인 JavaScript 런타임, 패키지 관리자, 테스트 러너 및 번들러입니다. Zig 프로그래밍 언어로 처음부터 구축되었으며, Node.js나 Deno와 달리 WebKit의 JavaScriptCore를 JavaScript 엔진으로 사용합니다. Bun은 가볍고 빠르며, **ES 모듈**, **async/await**와 같은 최신 JavaScript 기능을 완벽하게 지원하고, Node.js 및 웹 API를 광범위하게 구현하여 개발자 경험(DX)을 향상시키는 것을 목표로 합니다.

이 보고서는 2025년 상반기(1월~6월) 동안 Bun에 적용된 주요 변경 사항을 심층적으로 분석하고, 특히 코딩 구현에 영향을 미치는 핵심적인 발전 사항에 초점을 맞춥니다. Bun은 이 기간 동안 Node.js 호환성을 크게 강화하고, 새로운 내장 API를 도입하며, 전반적인 성능을 최적화하는 데 주력했습니다. 이러한 변화는 개발자들이 Bun을 활용하여 더욱 효율적이고 안정적인 애플리케이션을 구축하는 데 중요한 영향을 미칠 것으로 예상됩니다.

---

## 1. Bun의 핵심 내장 API 및 기능 확장

2025년 상반기 동안 Bun은 개발자 생산성과 애플리케이션 성능을 직접적으로 향상시키는 여러 핵심 내장 API와 기능을 추가했습니다. 이러한 기능들은 기존의 외부 라이브러리 의존성을 줄이고, Bun 런타임의 통합된 강점을 활용하도록 설계되었습니다.

### 1.1. Bun.s3 (내장 S3 객체 스토리지 API)

Bun은 이제 내장 S3 객체 스토리지 API인 **Bun.s3**를 제공합니다. 이 기능을 통해 개발자는 별도의 AWS SDK를 설치하거나 구성할 필요 없이 S3 버킷과 직접 상호작용할 수 있습니다. 이는 클라우드 네이티브 애플리케이션 개발을 간소화하고, 외부 종속성 관리의 복잡성을 줄이는 데 기여합니다.

코딩 구현 측면에서, **Bun.s3**는 객체 저장 방식을 최적화하기 위한 `storageClass` 옵션을 지원하여, 비용 또는 지연 시간에 따라 스토리지 클래스를 지정할 수 있습니다. 예를 들어, **GLACIER_IR**과 같은 스토리지 클래스를 사용하여 비용 효율적인 아카이빙을 구현할 수 있습니다. 또한, `client.list({ bucket: "my-bucket", prefix: "uploads/", maxKeys: 100 })`와 같이 **ListObjectsV2** 작업을 지원하여 S3 버킷 내의 객체를 페이지네이션 및 필터링 옵션과 함께 나열할 수 있습니다. 이러한 기능은 클라우드 스토리지와의 상호작용에서 성능을 높이고, 데이터 전송 속도를 개선하여 애플리케이션의 전반적인 효율성을 향상시킵니다.

### 1.2. Bun.sql (내장 Postgres 클라이언트)

Bun은 내장 Postgres 클라이언트인 **Bun.sql**을 도입하여 데이터베이스 상호작용을 위한 고성능 솔루션을 제공합니다. 이 클라이언트는 네이티브 코드로 작성되었으며, **자동 준비된 명령문(automatic prepared statements)**, **쿼리 파이프라이닝(query pipelining)**, 바이너리 와이어 프로토콜 지원, **연결 풀링(connection pooling)**, **구조 캐싱(structure caching)**과 같은 최적화 기능을 포함합니다.

코딩 구현 시, **Bun.sql**은 Unix 소켓을 통한 PostgreSQL 연결을 지원하여 로컬 데이터베이스 연결의 성능을 크게 향상시킬 수 있습니다. 예를 들어, `/tmp/.s.PGSQL.5432`와 같은 경로를 지정하여 Unix 소켓을 통해 연결할 수 있습니다. 또한, **sql 헬퍼 함수**를 사용하여 동적 컬럼 선택, 업데이트 작업 및 **WHERE IN** 절을 유연하게 구현할 수 있어 SQL 쿼리 작성을 더욱 직관적이고 강력하게 만듭니다. 이러한 기능은 데이터베이스 상호작용에서 발생하는 병목 현상을 줄이고, 데이터 접근 및 처리 속도를 가속화하여 데이터 집약적인 애플리케이션의 전반적인 성능을 높이는 데 기여합니다.

### 1.3. Bun.redis (내장 Redis 클라이언트)

Bun은 2025년 상반기 핵심적인 추가 사항으로 내장 Redis/Valkey 클라이언트인 **Bun.redis**를 선보였습니다. 이 클라이언트는 Zig 언어로 처음부터 작성되었으며, 기존의 인기 있는 Redis 클라이언트인 **ioredis**보다 벤치마크에서 44.82%에서 최대 85.39%까지 더 빠른 성능을 보여줍니다.

개발자들은 `await redis.set("foo", "bar")` 및 `await redis.get("foo")`와 같이 익숙한 Redis 명령을 직접 실행할 수 있습니다. 또한, `redis.getBuffer(key)` 메서드를 통해 바이너리 데이터를 효율적으로 검색할 수 있는 기능도 추가되었습니다. Redis는 캐싱, 세션 관리, 실시간 데이터 처리 등 다양한 용도로 활용되는 핵심 인메모리 데이터 스토어입니다. Bun이 Redis와의 상호작용에서 발생하는 오버헤드를 최소화함으로써, 캐싱 효율성을 높이고 실시간 애플리케이션의 응답성을 개선하는 데 중점을 둡니다. 이러한 내장 Redis 클라이언트는 마이크로서비스 아키텍처나 고부하 시스템에서 서비스 간 통신 및 데이터 공유의 병목 현상을 줄이는 데 기여할 수 있으며, 이는 Bun이 단일 서비스뿐만 아니라 분산 시스템 환경에서도 강력한 성능 이점을 제공하려 함을 의미합니다. 결과적으로 개발자들은 Redis를 사용하는 애플리케이션에서 Bun을 도입함으로써, 코드 변경 없이도 상당한 성능 향상을 기대할 수 있습니다.

### 1.4. Bun.CSRF (CSRF 토큰 생성 및 검증)

Bun은 웹 애플리케이션 보안을 강화하기 위해 **Bun.CSRF.generate** 및 **Bun.CSRF.verify** API를 v1.2.5에서 추가했습니다. 이 기능은 **Cross-Site Request Forgery (CSRF)** 공격으로부터 애플리케이션을 보호하는 데 사용됩니다.

개발자들은 `Bun.CSRF.generate()`를 사용하여 CSRF 토큰을 생성하고, `Bun.CSRF.verify(token)`를 통해 수신된 토큰을 검증할 수 있습니다. CSRF 방어는 웹 애플리케이션 보안의 기본 요소이며, Bun이 이러한 기능을 내장함으로써 개발자는 별도의 라이브러리나 복잡한 설정 없이도 필수적인 보안 기능을 쉽게 구현할 수 있습니다. 이는 보안 개발의 진입 장벽을 낮추고 개발 편의성을 높이는 데 기여합니다. 런타임 수준에서 보안 기능을 제공하는 것은 애플리케이션 전반에 걸쳐 일관된 보안 정책을 적용하기 용이하게 하며, 잠재적인 보안 취약점을 줄이는 데 도움이 됩니다. 이는 Bun이 단순히 성능뿐만 아니라 보안 측면에서도 신뢰할 수 있는 플랫폼이 되려 함을 보여줍니다.

### 1.5. Bun.hash.rapidhash (Rapidhash 지원)

v1.2.16 릴리스에서 **Bun.hash.rapidhash**가 추가되어 비암호학적 해싱 요구사항에 적합한 고성능 해싱 알고리즘을 제공합니다.

`Bun.hash.rapidhash("hello world")`와 같이 사용하여 빠르게 해시 값을 생성할 수 있으며, 특히 큰 입력에 대해 경쟁력 있는 성능을 보여줍니다. 해싱은 데이터 무결성 검사, 캐시 키 생성 등 다양한 유틸리티 작업에 사용됩니다. Bun은 핵심 런타임 기능 외에도, 개발자들이 일상적으로 사용하는 유틸리티 기능까지 성능을 최적화하여 개발 전반의 효율성을 높이고자 합니다. 이러한 미세한 성능 개선들이 모여 전체 애플리케이션의 성능을 향상시키는 데 기여하며, Bun이 개발자의 모든 작업 흐름에서 성능을 극대화하려는 세심한 접근 방식을 가지고 있음을 보여줍니다.

### 1.6. Bun.zstdCompress/Bun.zstdDecompress (Zstandard 압축 지원)

Bun은 v1.2.14에서 **Zstandard (zstd)** 압축 및 해제 유틸리티를 추가했습니다. 이와 함께 Bun의 HTTP 클라이언트는 **Content-Encoding: zstd** 응답을 자동으로 압축 해제하며, **Accept-Encoding** 헤더에 zstd를 포함하여 zstd 압축 응답을 요청할 수 있게 되었습니다.

개발자들은 `Bun.zstdCompressSync("hello world")` 및 `Bun.zstdDecompressSync(compressed)`와 같이 동기 및 비동기 API를 모두 활용하여 데이터를 압축하고 해제할 수 있습니다. Zstandard는 빠른 속도와 높은 압축률을 자랑하는 알고리즘으로, 데이터 압축은 네트워크 전송량과 스토리지 사용량을 줄이는 데 필수적입니다. Bun은 애플리케이션의 네트워크 및 스토리지 효율성을 향상시켜, 사용자 경험을 개선하고 운영 비용을 절감하는 데 기여합니다. 이는 Bun이 단순히 코드 실행 속도뿐만 아니라, 데이터 처리 및 전송과 관련된 전반적인 시스템 효율성까지 고려하고 있음을 의미하며, 특히 웹 서비스에서 이미지, 동영상 등 대용량 미디어 파일을 처리할 때 큰 이점을 제공할 수 있습니다.

### 1.7. 기타 주요 API 추가 및 개선

이 외에도 Bun은 여러 유용한 API를 추가하고 개선했습니다. v1.2.5에서는 쿠키를 가져오고 설정하는 데 사용되는 Map과 유사한 API인 **Bun.CookieMap**이 추가되었습니다. v1.2.1에서는 **Bun.inspect()**에서 `Symbol()` 객체의 서식 지정이 Node.js와 일치하도록 수정되어 디버깅 시 가독성이 향상되었습니다. 마지막으로, v1.2.9에서는 **Bun.connect()**를 통해 얻은 Socket 객체에 `localAddress`, `localFamily`, `remoteFamily`, `remotePort` 필드가 추가되어 소켓 및 피어 정보를 더 자세히 검사할 수 있게 되어 네트워크 연결 디버깅에 유용합니다.

| 기능명                                 | 설명                                                                 | 코딩 구현 시 주요 변경점/활용 예시                                                                                                     |
| :------------------------------------- | :------------------------------------------------------------------- | :------------------------------------------------------------------------------------------------------------------------------------- |
| **Bun.s3** | 내장 S3 객체 스토리지 API. 별도 SDK 없이 S3와 상호작용.              | `Bun.s3.presign({ storageClass: "GLACIER_IR" })`로 스토리지 클래스 지정. `client.list({ bucket: "my-bucket" })`로 객체 목록 조회. |
| **Bun.sql** | 내장 Postgres 클라이언트. 네이티브 코드 최적화.                      | `new Bun.SQL({ path: "/tmp/.s.PGSQL.5432" })`로 Unix 소켓 연결. `sql` 헬퍼 함수로 동적 컬럼/업데이트/WHERE IN 사용.                    |
| **Bun.redis** | 내장 Redis 클라이언트. `ioredis`보다 훨씬 빠른 성능.                 | `await redis.set("foo", "bar")`, `await redis.get("foo")`로 Redis 명령 실행. `redis.getBuffer(key)`로 바이너리 데이터 검색.             |
| **Bun.CSRF** | CSRF 토큰 생성 및 검증 API. 웹 애플리케이션 보안 강화.               | `Bun.CSRF.generate()`로 토큰 생성, `Bun.CSRF.verify(token)`로 검증.                                                                    |
| **Bun.hash.rapidhash** | 고성능 비암호학적 해싱 알고리즘.                                     | `Bun.hash.rapidhash("data")`로 빠른 해시 값 생성.                                                                                      |
| **Bun.zstdCompress / Bun.zstdDecompress** | Zstandard 압축/해제 유틸리티. HTTP 클라이언트 Zstandard 자동 지원. | `Bun.zstdCompressSync("data")` 및 `Bun.zstdDecompressSync(compressed)`로 데이터 압축/해제.                                            |
| **Bun.CookieMap** | 쿠키 관리용 Map과 유사한 API.                                        | `new Bun.CookieMap(object)`로 쿠키 객체 생성 및 관리.                                                                                  |
| **Bun.connect() Socket 필드 확장** | `Bun.connect()`로 얻은 Socket 객체에 로컬/원격 주소 및 패밀리 정보 추가. | `socket.localAddress`, `socket.remotePort` 등으로 연결 정보 상세 확인.                                                                  |

이 표는 2025년 상반기에 Bun에 추가된 핵심 API 및 내장 기능들을 한눈에 파악할 수 있도록 정보를 집약합니다. 각 기능에 대한 간략한 설명과 함께 코딩 구현 시의 주요 변경점 및 활용 예시를 제공하여, 개발자들이 실제 코드에 어떻게 적용할 수 있는지에 대한 실용적인 가이드를 제시합니다. 이는 새로운 프로젝트를 시작하거나 기존 프로젝트를 Bun으로 마이그레이션할 때 Bun이 제공하는 내장 기능들이 프로젝트의 요구사항을 충족시키는지 빠르게 판단하는 데 도움을 줍니다.

---

## 2. Node.js 호환성 강화

Bun의 핵심 목표 중 하나는 Node.js의 드롭인 대체품이 되는 것입니다. 2025년 상반기 동안 Bun은 이 목표를 달성하기 위해 Node.js 호환성을 크게 강화하는 데 집중했습니다.

### 2.1. 전반적인 호환성 전략

Bun은 Node.js의 드롭인 대체품으로 설계되었으며, Bun 1.2부터 모든 변경 사항에 대해 Node.js 테스트 스위트를 실행하기 시작하여 수천 개의 버그를 수정했습니다. 이는 Bun이 단순히 Node.js의 기능을 흉내 내는 것을 넘어, 동작 방식의 깊은 **패리티(parity)**를 목표로 함을 의미합니다. 이러한 노력은 Node.js 프로젝트를 Bun으로 마이그레이션할 때 발생하는 코드 변경 및 재작업의 필요성을 최소화하는 데 중점을 둡니다. 이는 개발자들이 성능 이점을 위해 런타임을 변경하는 데 따르는 위험과 비용을 크게 줄여줍니다. 높은 호환성은 기존 Node.js 생태계의 방대한 라이브러리와 프레임워크를 Bun에서 그대로 활용할 수 있게 하여, Bun의 채택률을 가속화하는 핵심 동력으로 작용합니다. 이는 Bun이 단순히 새로운 런타임이 아니라, 기존 JavaScript 생태계의 성능과 효율성을 극대화하는 "업그레이드"로서의 가치를 제공하려 함을 보여줍니다.

### 2.2. node:vm 모듈 개선

**node:vm** 모듈은 JavaScript 코드를 샌드박스 환경에서 실행하거나, 다른 컨텍스트에서 모듈을 평가하는 데 사용됩니다. v1.2.15에서는 **vm.SourceTextModule** 지원이 추가되어 ECMAScript 모듈을 다른 컨텍스트 내에서 평가할 수 있게 되었습니다. 이는 모듈 연결, 캐싱 메커니즘, 오류 전파 처리 등 **node:vm** 모듈과의 호환성을 크게 향상시킵니다. 또한, v1.2.6에서는 **vm.compileFunction** API가 구현되어 특정 인자와 컨텍스트를 가진 함수로 JavaScript 코드를 컴파일할 수 있게 되었습니다. 이 외에도 v1.1.41에서는 **JSDOM** 및 **happy-dom**의 안정성이 **node:vm** 호환성 개선으로 향상되었습니다. 이러한 개선은 **node:vm**이 코드 실행 환경을 격리하거나, 서버 사이드 렌더링(SSR) 프레임워크에서 클라이언트 코드를 미리 실행하는 데 중요하기 때문에, Bun이 Node.js의 고급 기능을 필요로 하는 복잡한 애플리케이션(예: 템플릿 엔진, SSR 프레임워크)에서도 안정적으로 작동할 수 있도록 기반을 다지고 있음을 의미합니다.

### 2.3. node:worker_threads 지원 강화

**node:worker_threads**는 JavaScript 애플리케이션에서 멀티스레딩을 구현하는 Node.js API입니다. v1.2.13에서 `worker_threads` 구현이 Node.js와 더욱 호환되도록 개선되었습니다. 부모 스레드와 워커 간에 데이터를 공유할 수 있는 **environmentData** API가 추가되었고, 워커 생성 시 `process` 객체에서 "worker" 이벤트를 수신하여 `threadId`를 얻을 수 있게 되었습니다. v1.2.15에서는 **Worker.getHeapSnapshot**이 지원되어 워커의 힙 사용량을 추적할 수 있게 되었습니다. 또한, v1.2.14에서는 `worker_threads`의 안정성이 개선되어, 처리되지 않은 예외 발생 시 Node.js와 동일하게 **Error** 객체를 방출하도록 변경되었습니다. v1.2.1 및 v1.2.2에서 워커 안정성 개선이 이루어졌으며, v1.2.13에서는 IPC를 사용하는 자식 프로세스의 메모리 사용량도 감소했습니다. 이러한 발전은 `worker_threads`가 CPU 집약적인 작업을 메인 스레드에서 분리하여 애플리케이션 응답성을 유지하는 데 필수적이며, Bun이 멀티스레딩을 활용하는 복잡한 애플리케이션에서 Node.js와 유사한 개발 경험을 제공하면서도, Bun 특유의 성능 및 메모리 효율성 이점을 누릴 수 있도록 지원함을 보여줍니다.

### 2.4. node:crypto 모듈 확장 및 최적화

**node:crypto** 모듈은 암호화 기능을 제공하며, 웹 애플리케이션의 보안에 필수적입니다. v1.2.5에서 `Sign`, `Verify`, `Hash`, `Hmac` 클래스가 C++로 재구현되어 **BoringSSL**을 활용한 하드웨어 가속으로 최대 34배 빠른 성능을 제공합니다. v1.2.6에서는 `Cipheriv`, `Decipheriv`, `DiffieHellman`, `DiffieHellmanGroup`, `ECDH`, `randomFill(Sync)`, `randomBytes` 등 더 많은 암호화 함수가 네이티브 코드로 재구현되어 성능이 크게 향상되었습니다. 특히 **DiffieHellman**은 105초에서 150ms로, `scrypt`는 365ms에서 47ms로 극적인 성능 향상을 보였습니다. 또한, v1.2.6에서 **hkdf (HMAC 기반 키 유도 함수)** 및 `hkdfSync`, `generatePrime`/`generatePrimeSync`, `checkPrime`/`checkPrimeSync` 함수가 구현되어 키 유도 및 소수 생성/검증이 가능해졌습니다. v1.2.6에서 ED25519 공개 키 생성 시 발생하던 메모리 오류가 수정되었으며, v1.2.9에서는 `Hmac` 및 `DiffieHellman` 생성자 관련 회귀 버그가 수정되었고, `createCipheriv`가 빈 옵션 객체로 호출될 때 오류를 발생시키던 문제가 해결되었습니다. v1.2.11에서는 **KeyObject** 클래스 계층이 완전히 구현되었고, `KeyObject` 및 `CryptoKey` 인스턴스에 대한 `structuredClone` 지원이 추가되었습니다. v1.2.11에서 **generatePrime(Sync)**의 반환 타입이 `Buffer`에서 `ArrayBuffer`로 수정되었습니다. 이러한 암호화 작업의 성능 극대화는 Bun이 TLS 통신, 데이터 암호화/복호화, 인증 등 보안 관련 기능이 필요한 애플리케이션에서 압도적인 성능 이점을 제공한다는 것을 의미하며, 이는 Bun이 고성능 웹 서버, 블록체인 애플리케이션 등 보안과 성능이 동시에 중요한 분야에서 강력한 대안이 될 수 있음을 시사합니다.

### 2.5. node:net 모듈 주요 재작업 및 호환성 개선

**node:net** 모듈은 TCP/IP 통신을 위한 네트워크 API를 제공하며, HTTP 서버, 클라이언트 등 네트워크 애플리케이션의 기반이 됩니다. v1.2.16에서 **node:net** 모듈이 대대적으로 재작업되어 Node.js 호환성이 크게 향상되었습니다. 43개의 새로운 Node.js **node:net** 테스트를 통과했으며, `server.maxConnections` 지원, 소켓 연결 콜백 동작 개선, TLS 업그레이드 기능 수정, `socket.localAddress()` 및 `socket.remoteAddress()` 수정, `dns.lookup` 호출 방식 일치, **net.BlockList** 지원 등이 포함됩니다. v1.2.5에서는 **net.connect()** 메서드의 유효성 검사가 강화되었고, `net.createServer`에 `AbortSignal`을 전달하여 서버를 중단할 수 있게 되었습니다. 또한 `server.unref()`가 `listen()` 호출 전에도 지속되도록 수정되었고, `net.connect()`의 무한 루프 버그, `resetAndDestroy()`, 소켓 타임아웃, `socket.write()` 인자 유효성 검사, `allowHalfOpen` 구현 등의 버그가 수정되었습니다. v1.2.4에서는 **SocketAddress** 클래스가 노출되었고, `net.Socket` 오류 처리 시 `JSC::Exception` 객체 대신 **Error** 인스턴스를 반환하도록 수정되었습니다. v1.2.9에서는 **node:net.Server.prototype.address()**가 localhost에서 리스닝할 때 호스트 이름을 올바르게 해결하도록 수정되었습니다. v1.2.5에서 `ipv6Only` 옵션이 제대로 작동하도록 수정되었고, v1.2.6에서 UDP 소켓의 캐시된 주소 재설정 버그가 수정되었으며, v1.2.5에서 소켓 오류 메시지가 `syscall`, `address`, `port` 속성을 포함하도록 개선되었습니다. 이러한 **node:net** 모듈에 대한 대규모 재작업과 수십 개의 버그 수정은 Bun이 복잡하고 다양한 네트워크 시나리오에서 Node.js와 동일한 수준의 신뢰성과 예측 가능한 동작을 보장하려 함을 의미합니다. 특히 연결 관리, 에러 핸들링, 리소스 해제와 같은 저수준 네트워크 작업의 정확성은 고가용성 시스템에서 매우 중요합니다.

### 2.6. node:fs 모듈 개선

**node:fs** 모듈은 파일 시스템과 상호작용하기 위한 API를 제공합니다. v1.2.2에서 `fs.glob`, `fs.globSync`, `fs.promises.glob` 함수가 Node.js API와 일치하게 지원되었으며, v1.2.17에서는 `options` 인자가 선택 사항이 되었습니다. v1.2.2에서 **fs.Dir** 구현이 Node.js 동작과 더 잘 일치하도록 유효성 검사 및 오류 처리가 개선되었습니다. 또한, v1.2.2에서 Windows에서 **fs.accessSync("../")**와 같이 `../` 세그먼트를 포함하는 상대 경로를 올바르게 처리하도록 수정되었습니다. v1.2.1에서 **fs.stat**이 더 적은 메모리를 사용하고, `fs.Stats` 생성자가 Node.js와 일치하게 되었으며, `fs.fstatSync`가 `bigint` 옵션을 지원하게 되었습니다. v1.2.1에서 **fs.writeFile** 및 **fs.readFile**에서 `EINTR` (시스템 호출 중단) 처리가 수정되었고, **fs.Dir.close** 회귀 버그도 수정되었습니다. v1.2.2에서 **fs.readdir**에 `withFileTypes` 옵션을 사용할 때 메모리 사용량이 감소했으며, v1.2.4에서 Windows에서 **stat** 호출 시 발생하던 어설션 실패 버그가 수정되었습니다. 마지막으로, v1.2.9에서는 **node:fs**에 영향을 미치던 가비지 컬렉션 엣지 케이스가 수정되었습니다. 이러한 파일 시스템 관련 작업의 개선은 Bun이 Node.js와의 높은 호환성을 유지하면서도, Bun 특유의 성능 및 리소스 효율성을 제공하여 개발자들이 더욱 빠르고 안정적으로 파일 시스템과 상호작용할 수 있도록 지원함을 의미합니다.

### 2.7. node:timers/node:timers/promises 개선

**node:timers** 및 **node:timers/promises** 모듈은 비동기 작업을 스케줄링하고 관리하는 데 사용됩니다. v1.2.17 및 v1.2.13에서 `setTimeout` 및 `setImmediate` 호출의 메모리 사용량이 8-15% 감소했습니다. v1.2.11에서는 **setImmediate**가 더 빨라졌습니다. v1.2.5에서 **setImmediate**가 `setInterval` 타이머와 함께 존재할 때 불필요한 유휴 상태를 유발하던 성능 문제가 수정되었습니다. v1.2.16에서는 **node:timers/promises** 함수가 `AbortController` 객체를 `options` 인자로 받아 타이머를 취소할 수 있게 되었습니다. 또한, v1.2.6에서는 **setTimeout**에 지연 시간 인자를 지정하지 않을 때 `TimeoutNaNWarning`이 잘못 방출되던 회귀 버그가 수정되었습니다. 이러한 개선은 비동기 로직의 실행 효율성을 높이고, 개발자가 타이머 및 비동기 작업을 더욱 세밀하게 제어할 수 있도록 지원하여 복잡한 비동기 애플리케이션의 개발 및 디버깅을 용이하게 합니다.

### 2.8. node:child_process 개선

**node:child_process** 모듈은 자식 프로세스를 생성하고 상호작용하는 데 사용됩니다. v1.2.17에서 `child_process.fork()`의 `execArgv` 옵션이 올바르게 구현되어 포크된 Bun 프로세스에 명령줄 인자를 전달할 수 있게 되었습니다. v1.2.9에서는 **Bun.spawn** 및 **node:child_process.spawn**에 `maxBuffer` 옵션이 추가되어 자식 프로세스의 출력 버퍼 크기를 제한하여 리소스 과소비를 방지할 수 있게 되었습니다. v1.2.13에서는 IPC(Inter-Process Communication)를 사용하는 자식 프로세스의 메모리 사용량이 감소했습니다. v1.2.1에서는 `child_process.spawn`의 여러 소켓을 포함하는 엣지 케이스에서 발생하던 레이스 컨디션 버그가 수정되었고, v1.2.5에서는 빈 IPC 메시지를 보낼 때 발생하던 어설션 오류가 수정되었습니다. 또한, v1.2.5에서 상속된 **stdin**을 가진 자식 프로세스가 `process.stdin` 대신 `null`을 반환하도록 수정되었습니다. 이러한 개선은 자식 프로세스 생성과 같은 외부 프로세스 관리 작업이 빌드 시스템, 외부 도구 실행, 시스템 명령 호출 등 다양한 개발 작업에 필수적임을 고려할 때, Bun이 외부 프로세스와의 상호작용에서 발생하는 잠재적인 문제를 해결하고, 개발자가 자식 프로세스의 리소스 사용을 더욱 효과적으로 제어할 수 있도록 지원함을 의미합니다.

### 2.9. require.extensions 및 require.resolve paths 옵션 지원

`require.extensions` 및 `require.resolve paths` 옵션은 Node.js의 모듈 로딩 방식을 커스터마이징하거나 모듈을 찾는 경로를 제어하는 데 사용됩니다. v1.2.9에서 **require.extensions** 객체가 완전히 지원되어 다양한 파일 확장자에 대한 사용자 정의 핸들러를 등록할 수 있게 되었습니다. 또한, v1.2.9에서 **require.resolve** 함수가 `paths` 옵션을 지원하여 모듈을 검색할 추가 디렉토리를 지정할 수 있게 되었습니다. v1.2.11에서는 `require.extensions` 처리의 엣지 케이스에서 발생하던 "index out of bounds" 충돌이 수정되었습니다. 이러한 기능들은 Node.js 초기 버전에서 많이 사용되었던 기능으로, 특정 파일 타입에 대한 커스텀 로딩 로직을 구현하는 데 사용됩니다. Bun은 이러한 Node.js의 레거시 및 고급 모듈 로딩 기능을 지원함으로써, 기존 Node.js 프로젝트의 마이그레이션을 더욱 원활하게 하고, 특정 모듈 로딩 시나리오에 대한 유연성을 제공합니다.

### 2.10. process.ref/process.unref 및 process.argv 개선

**process** 객체는 Node.js 애플리케이션의 전역 객체로, 현재 프로세스에 대한 정보를 제공하고 제어합니다. v1.2.11에서 `process.ref()` 및 `process.unref()` 메서드가 지원되어 객체가 이벤트 루프 종료를 방지하는지 여부를 제어하는 표준화된 방법을 제공합니다. v1.2.4에서는 **bun --print** 및 **bun --eval** 명령에서 `process.argv` 배열에 `[eval]`이 더 이상 포함되지 않도록 수정되어 Node.js의 동작과 일치하게 되었습니다. v1.2.17에서는 **process._eval** 속성이 지원되어 Bun이 `-e` 또는 `--eval` 플래그로 실행될 때 코드 문자열을 포함하게 되었습니다. v1.2.1에서는 **process.stdin.ref** 및 **process.stdin.unref**가 `undefined`이던 버그가 수정되었고, v1.2.4에서는 **process.stdin**에서 `pause()`를 즉시 호출할 때 프로세스가 종료되지 않던 버그가 수정되었습니다.

`process.ref`/`unref`는 이벤트 루프의 생명주기를 미세하게 제어하여, 백그라운드 작업이 완료될 때까지 프로세스가 종료되지 않도록 하거나, 반대로 불필요하게 프로세스가 유지되는 것을 방지합니다. Bun은 프로세스 수준의 제어 기능을 Node.js와 동일하게 제공함으로써, 개발자가 프로세스의 생명주기와 동작을 더욱 정밀하게 관리할 수 있도록 지원하며, 이는 장기 실행 서비스나 CLI 도구 개발에 중요합니다.

### 2.11. 기타 Node.js 모듈 호환성 버그 수정

2025년 상반기 동안 Bun은 다양한 Node.js 내장 모듈의 호환성 버그를 수정하고 기능을 개선했습니다. **Node-API** 구현은 v1.2.5에서 거의 완전히 재작성되어 Node.js의 `js-native-api` 테스트 스위트의 98%를 통과했으며, **napi_async_work** 생성 및 취소, N-API 문자열 변환, N-API 핸들 스코프 메모리 누수 관련 버그가 수정되었습니다.

**node:module**의 `module.children` 배열 지원이 v1.2.6에 추가되었고, **node:test** 모듈에 대한 초기 지원도 v1.2.6에 포함되었습니다.

**node:http2**는 v1.2.14에서 서버 및 클라이언트 개선이 이루어졌으며, Bun 1.2에서 HTTP/2 서버가 Node.js보다 2배 빨라졌고, v1.2.6에서 호환성 개선이 이루어졌습니다. v1.2.16에서는 흐름 제어 및 프로토콜 처리 문제가 수정되었습니다.

**node:os**의 `os.loadavg()` 값은 v1.2.2에서 macOS에서 정확하게 수정되었고, **node:zlib**는 v1.2.17에서 Zstandard (zstd) 압축 및 해제 지원이 추가되었습니다.

**node:readline/promises**의 오류 처리는 v1.2.11에서 수정되었고, **HTTPParser** 바인딩은 v1.2.16에 추가되었습니다.

`util.promisify`는 v1.2.13에서 함수 이름이 보존되고, 이미 Promise를 반환하는 함수에 대해 경고가 발생하도록 개선되었습니다.

**DOMException**은 v1.2.13에서 `name` 및 `cause` 속성을 지원하게 되었고, **pnpm** 호환성은 v1.2.2에서 수정되었습니다.

`$NODE_PATH` 환경 변수를 통한 모듈 로딩은 v1.2.2에서 지원되며, **Nuxt & Vite 6** 호환성도 v1.2.2에서 개선되었습니다.

**WebSocket** 및 관련 전역 객체는 v1.2.2에서 `node:http`에서 재내보내기됩니다.

**ERR_EVENT_RECURSION**은 v1.2.14에서 예상대로 발생하도록 수정되었고, `util.inherits`는 v1.2.14에서 `bun build --target=browser` 시 존재하지 않던 문제가 해결되었습니다. 마지막으로, `vm.SyntheticModule` 구현은 v1.2.16에 추가되었고, `process.binding('http_parser')`는 v1.2.16에 추가되어 Node.js HTTP 내부와의 호환성이 향상되었습니다.

---

## 3. 성능 최적화

Bun의 핵심 강점은 속도와 효율성입니다. 2025년 상반기 동안 Bun은 여러 방면에서 성능을 최적화하여 이러한 강점을 더욱 공고히 했습니다.

### 3.1. JavaScriptCore 업그레이드 및 JIT 개선

Bun은 WebKit의 **JavaScriptCore** 엔진을 사용하며, 이 엔진의 업그레이드는 Bun의 전반적인 JavaScript 실행 성능에 직접적인 영향을 미칩니다. v1.2.17, v1.2.15, v1.2.9 릴리스에 걸쳐 `JavaScriptCore`가 업그레이드되었습니다. 주요 개선 사항으로는 `str += str` 패턴에 대한 더 효율적인 코드 생성, `String.prototype.charCodeAt()` 및 `charAt()`의 JIT 컴파일-타임 폴딩, JavaScriptCore의 DFG JIT에서 문자열 타입 추적 개선, `Number.isFinite()`의 C++ 재작성(1.6배 빠름), 배열 메서드 최적화(`Int32` 배열에서 `indexOf`/`includes` 4.7-5.2배 빠름), NaN 처리 개선, ARM64 및 x64 아키텍처를 위한 `convertUInt32ToDouble`/`convertUInt32ToFloat` 함수 추가 등이 있습니다. JSON 문자열화 시 동적 할당 버퍼를 직접 채택하는 **제로-카피 문자열화** 기능이 추가되어 대용량 JSON 문자열 처리 시 메모리 할당 및 복사 오버헤드가 제거되었습니다. 또한, 옵티마이저 개선에는 상수 경계 및 범위 분석을 통한 **CheckInBounds** 작업 처리 개선, **ArithBitAnd** 작업에 대한 범위 분석 등이 포함되어 런타임 경계 검사를 줄입니다. 이러한 개선은 Bun이 단순히 외부 라이브러리 최적화를 넘어, JavaScript 코드 자체의 실행 효율성을 근본적으로 높이고 있음을 의미합니다. 이는 다른 런타임이 쉽게 따라잡기 어려운 내재적인 성능 우위를 제공하며, Bun이 고성능 컴퓨팅, 대규모 데이터 처리, 실시간 시스템 등 성능이 핵심인 분야에서 강력한 경쟁력을 갖추게 합니다.

### 3.2. 메모리 사용량 감소

Bun은 경량성을 목표로 하며, 메모리 사용량 최적화는 이 목표의 핵심 부분입니다. v1.2.2에서 JavaScript 유휴 메모리 사용량이 10-30% 감소했습니다. 이는 JavaScriptCore의 가비지 컬렉터 타이머가 Bun의 이벤트 루프에 통합되어 GC가 적절한 시점에 실행되도록 한 결과입니다. v1.2.17 및 v1.2.13에서 **setTimeout** 및 **setImmediate** 호출의 메모리 사용량이 8-15% 감소했습니다. 또한, v1.2.13에서 자식 프로세스 IPC의 메모리 사용량이 감소했으며, v1.2.1에서 **fs.stat**이 더 적은 메모리를 사용하고, v1.2.2에서 **fs.readdir**에 `withFileTypes` 옵션을 사용할 때 메모리 사용량이 감소했습니다. v1.2.5에서는 타이머가 반환하는 객체의 메모리 사용량이 8바이트 감소했습니다. 메모리 사용량은 클라우드 환경에서 운영 비용과 직결되며, 리소스 제약이 있는 환경(예: 서버리스 함수)에서 중요합니다. Bun은 애플리케이션의 메모리 발자국을 최소화하여, 더 적은 리소스로 더 많은 작업을 처리할 수 있게 합니다. 이는 클라우드 비용을 절감하고, 시스템의 안정성을 높이며, 더 많은 애플리케이션을 단일 서버에 배포할 수 있게 합니다.

### 3.3. Bun.build 속도 향상 (macOS)

**Bun.build**는 Bun의 내장 번들러로, 애플리케이션을 빌드하는 데 사용됩니다. v1.2.4에서 macOS 및 Windows에서 빌드 중 파일 작업에 전용 I/O 스레드 풀을 사용하여 **Bun.build**가 macOS에서 최대 60% 더 빨라졌습니다. 빌드 시간은 개발 워크플로우에서 반복적으로 발생하는 지연 요소입니다. **Bun.build**의 속도 향상은 개발자가 코드를 변경하고 결과를 확인하는 주기를 가속화하여, 전반적인 개발 생산성을 직접적으로 향상시킵니다. 이는 특히 대규모 프로젝트에서 큰 이점을 제공합니다.

### 3.4. Express 및 Fastify 성능 개선

**Express** 및 **Fastify**는 Node.js 생태계에서 널리 사용되는 웹 프레임워크입니다. Bun 1.2에서 `Express`가 3배 더 빨라졌으며, v1.2.6에서는 **node:http** 호환성 개선으로 `Express`가 9%, `Fastify`가 5.4% 더 빨라졌습니다. 많은 기존 Node.js 애플리케이션이 `Express`나 `Fastify`를 사용합니다. Bun은 이들 프레임워크를 Bun 위에서 실행할 때 상당한 성능 향상을 제공합니다. Bun은 기존 Node.js 생태계와의 호환성을 유지하면서, 이미 널리 사용되는 프레임워크들의 성능을 Bun의 고유한 아키텍처를 통해 극대화합니다. 이는 개발자들이 기존 코드를 크게 변경하지 않고도 성능 이점을 얻을 수 있게 하여, Bun으로의 전환을 더욱 매력적으로 만듭니다.

### 3.5. Array.prototype.includes 및 TextDecoder 초기화 속도 향상

`Array.prototype.includes` 및 **TextDecoder**는 JavaScript에서 흔히 사용되는 내장 함수 및 API입니다. v1.2.4에서 WebKit의 `Array.prototype.includes` C++ 재작성으로 1.2-2.8배 빨라졌으며, v1.2.9에서는 **Array.prototype.indexOf`/`includes**가 `Int32` 배열에서 4.7-5.2배 빨라졌습니다. 또한, v1.2.5에서는 **TextDecoder** 초기화가 30% 더 빨라졌습니다. 이러한 기본 API의 최적화는 Bun의 세심한 성능 접근 방식을 보여줍니다. `Array.prototype.includes`나 `TextDecoder`와 같이 자주 사용되는 함수에서의 작은 속도 향상도 전체 애플리케이션 성능에 상당한 영향을 미치며, Bun 위에서 실행되는 모든 애플리케이션에 이점을 제공합니다.

---

## 결론

2025년 상반기 동안 Bun은 JavaScript 런타임 환경에서 강력한 성능과 광범위한 호환성을 제공하려는 목표를 향해 눈부신 발전을 이루었습니다. 이 기간 동안 Bun은 Node.js의 드롭인 대체품으로서의 입지를 공고히 하고, 다양한 개발 시나리오에서 탁월한 효율성을 제공하는 데 주력했습니다.

특히, 내장 **Bun.s3**, **Bun.sql**, **Bun.redis** 클라이언트의 도입은 개발자들이 외부 종속성 없이도 클라우드 스토리지, 관계형 데이터베이스, 인메모리 데이터 스토어와 직접적이고 고성능으로 상호작용할 수 있게 했습니다. 이는 애플리케이션의 복잡성을 줄이고, 데이터 처리 및 전송 효율성을 극대화하여 실시간 시스템 및 고부하 서비스에 매우 유리합니다. 또한, **Bun.CSRF**와 같은 보안 기능의 내재화는 개발 편의성을 높이고 애플리케이션의 전반적인 보안 수준을 향상시키는 데 기여했습니다.

Node.js 호환성 측면에서는 **node:vm**, **node:worker_threads**, **node:crypto**, **node:net**, **node:fs** 등 핵심 모듈에 대한 대규모 개선과 수많은 버그 수정이 이루어졌습니다. 이는 기존 Node.js 프로젝트의 Bun으로의 마이그레이션 장벽을 최소화하고, Node.js 생태계의 방대한 라이브러리와 프레임워크를 Bun에서 안정적으로 활용할 수 있게 합니다. 특히 **node:crypto** 모듈의 하드웨어 가속을 통한 극적인 성능 향상은 보안이 중요한 애플리케이션에서 Bun의 경쟁력을 크게 높였습니다.

성능 최적화는 **JavaScriptCore** 엔진의 지속적인 업그레이드, JIT 컴파일러의 개선, 그리고 유휴 메모리 사용량 및 `setTimeout`/`setImmediate` 호출의 메모리 사용량 감소를 통해 이루어졌습니다. **Bun.build**의 속도 향상과 **Express**, **Fastify**와 같은 인기 웹 프레임워크의 성능 개선은 개발 생산성을 직접적으로 높이고 기존 애플리케이션의 성능을 극대화하는 효과를 가져왔습니다.

종합적으로 볼 때, 2025년 상반기의 Bun 변경 사항들은 Bun이 단순한 신규 런타임을 넘어, 기존 JavaScript 생태계의 성능과 효율성을 혁신적으로 끌어올리는 강력한 도구로 자리매김하고 있음을 분명히 보여줍니다. 개발자들은 이제 Bun을 통해 더욱 빠르고, 안전하며, 리소스 효율적인 애플리케이션을 구축할 수 있는 강력한 기반을 확보하게 되었습니다.
